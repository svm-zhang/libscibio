{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tinyscibio","text":"<p>Python library providing convenient functions to boost daily biological science research.</p>"},{"location":"#installation","title":"Installation","text":"<p>Coming soon..</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Coming soon..</p>"},{"location":"API/api_server/","title":"module requesting API service","text":""},{"location":"API/api_server/#tinyscibio.api_server.request_api_server","title":"<code>request_api_server(url, params=None, headers=None, timeout=None, stream=False)</code>","text":"<p>Connect to an API server given configuration and return a Response object.</p> <p>This is a wrapper around the get function from the requests package. I use this to query various remote biology databases with APIs, for instance, Varsome, Ensembl, GTEx, cBioPortal, etc.</p> <p>Examples:</p> <p>Let us query the Varsome API server to annotate a variant with ACMG information. Varsome requires API token to use the service. Provide an API token inside the HTTP header; otherwise, you can only run one API query once per day. The specific variant used here is from https://api.varsome.com/.</p> <pre><code>&gt;&gt;&gt; from tinyscibio import request_api_server\n&gt;&gt;&gt; api_server_url = \"https://api.varsome.com/lookup/\"\n&gt;&gt;&gt; qry = \"15-73027478-T-C\"\n&gt;&gt;&gt; lookup_path = f\"{api_server_url}{qry}\"\n&gt;&gt;&gt; qry_params = {\n        \"add_ACMG_annotation\": 1\n    }\n&gt;&gt;&gt; headers = {\"Accept\": \"application/json\"}\n&gt;&gt;&gt; response = request_api_server(\n        lookup_path,\n        qry_params,\n        headers\n    )\n&gt;&gt;&gt; assert response.status_code == 200  # if the connection is success\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>lookup path (not just the API server URL).</p> required <code>params</code> <code>Optional[_RequestParamsType]</code> <p>query parameters to defined what you want to request.</p> <code>None</code> <code>headers</code> <code>Optional[_RequestHeaderType]</code> <p>HTTP headers.</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>How many seconds to wait for the server to send data      before giving up.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Whether or not getting response data immediately.</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A requests.Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>When HTTP error occurred.</p> <code>Timeout</code> <p>When request timed out.</p> <code>ConnectionError</code> <p>When connection error occurred.</p> <code>RequestException</code> <p>All other errors not covered by the above ones.</p>"},{"location":"API/bam/","title":"Module dealing with anything related to BAM file","text":""},{"location":"API/bam/#tinyscibio.bam.BAMetadata","title":"<code>BAMetadata(fspath)</code>  <code>dataclass</code>","text":"<p>A BAMetadata object holds metadata about a given BAM file.</p> <p>Examples:</p> <p>Let us use a hypothetical coordiante-sorted BAM file with one read group and two references, as an example:</p> <pre><code>&gt;&gt;&gt; bametadata = BAMetadata(\"test.bam\")\n&gt;&gt;&gt; print(bametadata.sort_by)\ncoordinate\n&gt;&gt;&gt; print(bametadata.read_groups)\n[{\"ID\": \"test\", \"SM\": \"test\"}]\n&gt;&gt;&gt; print(bametadata.references)\n[{\"r1\": 1000}, {\"r2\": 2000}]\n&gt;&gt;&gt; print(bametadata)\nBAM file: test.bam\nSort by: coordinate\n# references: 2\n# read groups: 1\n</code></pre> <p>Attributes:</p> Name Type Description <code>fspath</code> <code>str</code> <p>path to the BAM file</p> <code>sort_by</code> <code>str</code> <p>sort state, e.g. unknown, unsorted, queryname, and coordinate.</p> <code>references</code> <code>list[dict[str, int]]</code> <p>list of mappings of reference name to its length.</p> <code>read_groups</code> <code>list[dict[str, str]]</code> <p>list of read group dictionaries</p>"},{"location":"API/bam/#tinyscibio.bam.count_indel_bases","title":"<code>count_indel_bases(cigar)</code>","text":"<p>Count the length of indels in the given CIGAR string.</p> <p>The function counts the number of bases, rather than events.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45M9D27M1I20M5S\"\n&gt;&gt;&gt; assert count_indel_bases(cigar_str) == 10\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_indel_bases(cigar_list) == 1\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of inserted and deleted bases.</p>"},{"location":"API/bam/#tinyscibio.bam.count_indel_events","title":"<code>count_indel_events(cigar)</code>","text":"<p>Count the number of Is and Ds event in a given CIGAR string.</p> <p>Indel events include: insertion(I) and deletion(D).</p> <p>The function counts the number of events, rather than inserted and deleted bases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_indel_events(cigar_str) == 2\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_indel_events(cigar_list) == 1\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of insertion and deletion events.</p>"},{"location":"API/bam/#tinyscibio.bam.count_mismatch_events","title":"<code>count_mismatch_events(md)</code>","text":"<p>Count the number of mismatch events in a given MD string.</p> <p>Mismatches are represented by any non-digit characters, e.g. A, C, G, ^T.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md_str = \"10A3T0T10\"\n&gt;&gt;&gt; assert count_mismatch_events(md_str) == 3\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; md_list = [\"85\", \"^A\", \"16\"] # an inserted base A on the read\n&gt;&gt;&gt; assert count_mismatch_events(md_list) == 0\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Union[str, Sequence[str]]</code> <p>a CIGAR string or a list strings parsed from parse_md() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of mismatch events.</p>"},{"location":"API/bam/#tinyscibio.bam.count_soft_clip_bases","title":"<code>count_soft_clip_bases(cigar)</code>","text":"<p>Count the number of soft-clipped bases from a given CIGAR string.</p> <p>Soft-clipped bases are represented as \"S\" in the CIGAR string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert count_soft_clip_bases(cigar_str) == 27\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_soft_clip_bases(cigar_list) == 0\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert count_soft_clip_bases(parse_cigar(cigar_str)) == 27 # use result from parse_cigar function\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of soft-clipped bases.</p>"},{"location":"API/bam/#tinyscibio.bam.count_unaligned_events","title":"<code>count_unaligned_events(cigar)</code>","text":"<p>Count the number of unaligned events in a given CIGAR string.</p> <p>Unaligned events in this context include: insertion(I), deletion(D), soft-clipping(S), and hard-clipping(H).</p> <p>The function counts the number of events, rather than unaligned bases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_unaligned_events(cigar_str) == 4\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_unaligned_events(cigar_list) == 1\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_unaligned_events(parse_cigar(cigar_str)) == 4\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of unaligned events.</p>"},{"location":"API/bam/#tinyscibio.bam.parse_cigar","title":"<code>parse_cigar(cigar)</code>","text":"<p>Parse a given CIGAR string into a list of tuple items of (length, operation).</p> <p>Valid operations in a CIGAR string are: M, I, D, N, S, H, P, =, and X.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert parse_cigar(cigar_str) == [\n    (\"27\", \"S\"),\n    (\"89\", \"M\"),\n    (\"1\", \"I\"),\n    (\"11\", \"M\")\n]\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>str</code> <p>a CIGAR string</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>A list of tuple items, each of which consists of length and operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given CIGAR string is empty, or when the CIGAR string         parsed into an empty list, or when failure of reconstructing         parsed list back to the original CIGAR string.</p>"},{"location":"API/bam/#tinyscibio.bam.parse_md","title":"<code>parse_md(md)</code>","text":"<p>Parse a given MD string into a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md_str = \"10A3T0T10\"\n&gt;&gt;&gt; assert parse_cigar(cigar_str) == [\n        \"10\", \"A\", \"3\", \"T\", \"0\", \"T\", \"10\"\n    ]\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>str</code> <p>a MD string</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of strings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given MD string is empty, or when the MD string         parsed into an empty list, or when failure of reconstructing         parsed list back to the original MD string.</p>"},{"location":"API/io/","title":"I/O module","text":""},{"location":"API/io/#tinyscibio._io.parse_path","title":"<code>parse_path(path)</code>","text":"<p>Parse a string literal or a Path object into a Path object.</p> <p>In the latter case, the function does not do anything but return the given Path object directly.</p> <p>I also use this function to directly parse file and directory input strings passed in from command line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; p = \"/home/user1/project\"\n&gt;&gt;&gt; parse_path(p)\nPath(\"/home/user1/project\")\n</code></pre> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; p_obj = Path(\"/home/user1/project\")\n&gt;&gt;&gt; parse_path(p_obj)\nPath(\"/home/user1/project\")\n</code></pre> <pre><code>&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; parser = argparse.ArgumentParser()\n&gt;&gt;&gt; parser.add_argument(\n        \"--bam\",\n        metavar=\"FILE\",\n        type=parse_path,\n        help=\"Specify the path to the BAM file\"\n    )\n&gt;&gt;&gt; args = parser.parse_args()\n&gt;&gt;&gt; isinstance(args.bam, Path)\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A Path object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When input path parameter is an empty string</p>"},{"location":"API/io/#tinyscibio._io.make_dir","title":"<code>make_dir(path, parents=False, exist_ok=False)</code>","text":"<p>Create a directory at the specified location.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import make_dir\n&gt;&gt;&gt; p = \"/home/user1/projects\"\n&gt;&gt;&gt; make_dir(p, parents=True, exist_ok=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <code>parents</code> <code>bool</code> <p>Whether or not creating parental folders leading      to the given path when not existed.</p> <code>False</code> <code>exist_ok</code> <code>bool</code> <p>Whether or not allowing the directory trying to be       created already existed.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>When parental folders leading to the given path                does not exists, and parents parameter is False</p> <code>FileExistsError</code> <p>When trying to create a directory that already              existed, and exist_ok parameter is False.              Or when trying to create a directory at the given              location leading to a file.</p>"},{"location":"API/io/#tinyscibio._io.get_parent_dir","title":"<code>get_parent_dir(path, level=0)</code>","text":"<p>Get parent directory at the specified level for a given path.</p> <p>Setting a level=0 means return the given path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import get_parent_dir\n&gt;&gt;&gt; p = \"/home/user1/projects\"\n&gt;&gt;&gt; get_parent_dir(p, level=1)\nPath(\"/home/user1/\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <code>level</code> <code>int</code> <p>Num of levels to walk back along a givne path</p> <code>0</code> <p>Returns:</p> Type Description <code>Path</code> <p>A Path object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the value of level is negative or larger than         the number of parent folders in the given path</p>"}]}